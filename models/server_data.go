package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
	"github.com/latitudesh/lsh/internal/output/table"
)

// ServerData server data
//
// swagger:model server_data
type ServerData struct {

	// attributes
	Attributes *ServerDataAttributes `json:"attributes,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// type
	Type string `json:"type,omitempty"`
}

// Validate validates this server data
func (m *ServerData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttributes(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerData) validateAttributes(formats strfmt.Registry) error {
	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	if m.Attributes != nil {
		if err := m.Attributes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this server data based on the context it is used
func (m *ServerData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAttributes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerData) contextValidateAttributes(ctx context.Context, formats strfmt.Registry) error {

	if m.Attributes != nil {

		if swag.IsZero(m.Attributes) { // not required
			return nil
		}

		if err := m.Attributes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServerData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerData) UnmarshalBinary(b []byte) error {
	var res ServerData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

func (m *ServerData) TableRow() table.Row {
	attr := m.Attributes

	return table.Row{
		"id": table.Cell{
			Label: "ID",
			Value: table.String(m.ID),
		},
		"hostname": table.Cell{
			Label:     "Hostname",
			Value:     table.String(attr.Hostname),
			MaxLength: 15,
		},
		"primary_ipv4": table.Cell{
			Label: "Primary IPV4",
			Value: table.String(*attr.PrimaryIPV4),
		},
		"location": table.Cell{
			Label: "Location",
			Value: table.String(location(attr)),
		},
		"status": table.Cell{
			Label: "Status",
			Value: table.String(attr.Status),
		},
		"ipmi_status": table.Cell{
			Label: "IPMI Status",
			Value: table.String(attr.IpmiStatus),
		},
		"project": table.Cell{
			Label: "Project",
			Value: table.String(project(attr)),
		},
		"plan": table.Cell{
			Label: "Plan",
			Value: table.String(plan(attr)),
		},
		"operating_system": table.Cell{
			Label:     "OS",
			Value:     table.String(operatingSystem(attr)),
			MaxLength: 10,
		},
	}
}

func location(attributes *ServerDataAttributes) string {
	region := attributes.Region

	if region != nil && region.Site != nil {
		return region.Site.Slug
	}

	return ""
}

func project(attributes *ServerDataAttributes) string {
	project := attributes.Project

	if project != nil {
		return project.Slug
	}

	return ""
}

func operatingSystem(attributes *ServerDataAttributes) string {
	operatingSystem := attributes.OperatingSystem

	if operatingSystem != nil {
		return operatingSystem.Slug
	}

	return ""
}

func plan(attributes *ServerDataAttributes) string {
	plan := attributes.Plan

	if plan != nil {
		return plan.Name
	}

	return ""
}

// ServerDataAttributes server data attributes
//
// swagger:model ServerDataAttributes
type ServerDataAttributes struct {

	// created at
	CreatedAt *string `json:"created_at,omitempty"`

	// hostname
	Hostname string `json:"hostname,omitempty"`

	// ipmi status
	// Enum: [Unavailable Intermittent Normal]
	IpmiStatus string `json:"ipmi_status,omitempty"`

	// operating system
	OperatingSystem *ServerDataAttributesOperatingSystem `json:"operating_system,omitempty"`

	// plan
	Plan *ServerDataAttributesPlan `json:"plan,omitempty"`

	// primary ipv4
	PrimaryIPV4 *string `json:"primary_ipv4,omitempty"`

	// project
	Project *ProjectInclude `json:"project,omitempty"`

	// region
	Region *RegionResourceData `json:"region,omitempty"`

	// role
	Role string `json:"role,omitempty"`

	// scheduled deletion at
	ScheduledDeletionAt *string `json:"scheduled_deletion_at,omitempty"`

	// site
	Site string `json:"site,omitempty"`

	// specs
	Specs *ServerDataAttributesSpecs `json:"specs,omitempty"`

	// `on` - The server is powered ON
	// `off` - The server is powered OFF
	// `unknown` - The server power status is unknown
	// `ready` - The server is in reinstalling state `ready` and should start `disk_erasing` shortly
	// `disk_erasing` - The server is in reinstalling state `disk_erasing`
	// `failed_disk_erasing` - The server has failed disk erasing in reinstall
	// `deploying` - The server is in the last reinstalling stage and is `deploying`
	// `failed_deployment` The server has failed deployment in reinstall
	//
	// Enum: [on off unknown ready disk_erasing failed_disk_erasing deploying failed_deployment]
	Status string `json:"status,omitempty"`

	// team
	Team *TeamInclude `json:"team,omitempty"`
}

// Validate validates this server data attributes
func (m *ServerDataAttributes) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIpmiStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperatingSystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpecs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeam(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var serverDataAttributesTypeIpmiStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unavailable","Intermittent","Normal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDataAttributesTypeIpmiStatusPropEnum = append(serverDataAttributesTypeIpmiStatusPropEnum, v)
	}
}

const (

	// ServerDataAttributesIpmiStatusUnavailable captures enum value "Unavailable"
	ServerDataAttributesIpmiStatusUnavailable string = "Unavailable"

	// ServerDataAttributesIpmiStatusIntermittent captures enum value "Intermittent"
	ServerDataAttributesIpmiStatusIntermittent string = "Intermittent"

	// ServerDataAttributesIpmiStatusNormal captures enum value "Normal"
	ServerDataAttributesIpmiStatusNormal string = "Normal"
)

// prop value enum
func (m *ServerDataAttributes) validateIpmiStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDataAttributesTypeIpmiStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDataAttributes) validateIpmiStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.IpmiStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateIpmiStatusEnum("attributes"+"."+"ipmi_status", "body", m.IpmiStatus); err != nil {
		return err
	}

	return nil
}

func (m *ServerDataAttributes) validateOperatingSystem(formats strfmt.Registry) error {
	if swag.IsZero(m.OperatingSystem) { // not required
		return nil
	}

	if m.OperatingSystem != nil {
		if err := m.OperatingSystem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) validatePlan(formats strfmt.Registry) error {
	if swag.IsZero(m.Plan) { // not required
		return nil
	}

	if m.Plan != nil {
		if err := m.Plan.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "plan")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "plan")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) validateProject(formats strfmt.Registry) error {
	if swag.IsZero(m.Project) { // not required
		return nil
	}

	if m.Project != nil {
		if err := m.Project.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "project")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "project")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) validateRegion(formats strfmt.Registry) error {
	if swag.IsZero(m.Region) { // not required
		return nil
	}

	if m.Region != nil {
		if err := m.Region.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "region")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "region")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) validateSpecs(formats strfmt.Registry) error {
	if swag.IsZero(m.Specs) { // not required
		return nil
	}

	if m.Specs != nil {
		if err := m.Specs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "specs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "specs")
			}
			return err
		}
	}

	return nil
}

var serverDataAttributesTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["on","off","unknown","ready","disk_erasing","failed_disk_erasing","deploying","failed_deployment"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		serverDataAttributesTypeStatusPropEnum = append(serverDataAttributesTypeStatusPropEnum, v)
	}
}

const (

	// ServerDataAttributesStatusOn captures enum value "on"
	ServerDataAttributesStatusOn string = "on"

	// ServerDataAttributesStatusOff captures enum value "off"
	ServerDataAttributesStatusOff string = "off"

	// ServerDataAttributesStatusUnknown captures enum value "unknown"
	ServerDataAttributesStatusUnknown string = "unknown"

	// ServerDataAttributesStatusReady captures enum value "ready"
	ServerDataAttributesStatusReady string = "ready"

	// ServerDataAttributesStatusDiskErasing captures enum value "disk_erasing"
	ServerDataAttributesStatusDiskErasing string = "disk_erasing"

	// ServerDataAttributesStatusFailedDiskErasing captures enum value "failed_disk_erasing"
	ServerDataAttributesStatusFailedDiskErasing string = "failed_disk_erasing"

	// ServerDataAttributesStatusDeploying captures enum value "deploying"
	ServerDataAttributesStatusDeploying string = "deploying"

	// ServerDataAttributesStatusFailedDeployment captures enum value "failed_deployment"
	ServerDataAttributesStatusFailedDeployment string = "failed_deployment"
)

// prop value enum
func (m *ServerDataAttributes) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, serverDataAttributesTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ServerDataAttributes) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("attributes"+"."+"status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ServerDataAttributes) validateTeam(formats strfmt.Registry) error {
	if swag.IsZero(m.Team) { // not required
		return nil
	}

	if m.Team != nil {
		if err := m.Team.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "team")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this server data attributes based on the context it is used
func (m *ServerDataAttributes) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateOperatingSystem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateProject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRegion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpecs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTeam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerDataAttributes) contextValidateOperatingSystem(ctx context.Context, formats strfmt.Registry) error {

	if m.OperatingSystem != nil {

		if swag.IsZero(m.OperatingSystem) { // not required
			return nil
		}

		if err := m.OperatingSystem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) contextValidatePlan(ctx context.Context, formats strfmt.Registry) error {

	if m.Plan != nil {

		if swag.IsZero(m.Plan) { // not required
			return nil
		}

		if err := m.Plan.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "plan")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "plan")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) contextValidateProject(ctx context.Context, formats strfmt.Registry) error {

	if m.Project != nil {

		if swag.IsZero(m.Project) { // not required
			return nil
		}

		if err := m.Project.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "project")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "project")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) contextValidateRegion(ctx context.Context, formats strfmt.Registry) error {

	if m.Region != nil {

		if swag.IsZero(m.Region) { // not required
			return nil
		}

		if err := m.Region.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "region")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "region")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) contextValidateSpecs(ctx context.Context, formats strfmt.Registry) error {

	if m.Specs != nil {

		if swag.IsZero(m.Specs) { // not required
			return nil
		}

		if err := m.Specs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "specs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "specs")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributes) contextValidateTeam(ctx context.Context, formats strfmt.Registry) error {

	if m.Team != nil {

		if swag.IsZero(m.Team) { // not required
			return nil
		}

		if err := m.Team.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "team")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributes) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributes) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ServerDataAttributesOperatingSystem server data attributes operating system
//
// swagger:model ServerDataAttributesOperatingSystem
type ServerDataAttributesOperatingSystem struct {

	// distro
	Distro *ServerDataAttributesOperatingSystemDistro `json:"distro,omitempty"`

	// features
	Features *ServerDataAttributesOperatingSystemFeatures `json:"features,omitempty"`

	// The OS name
	Name string `json:"name,omitempty"`

	// The OS slug
	Slug string `json:"slug,omitempty"`

	// The OS description
	Version string `json:"version,omitempty"`
}

// Validate validates this server data attributes operating system
func (m *ServerDataAttributesOperatingSystem) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDistro(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerDataAttributesOperatingSystem) validateDistro(formats strfmt.Registry) error {
	if swag.IsZero(m.Distro) { // not required
		return nil
	}

	if m.Distro != nil {
		if err := m.Distro.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system" + "." + "distro")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system" + "." + "distro")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributesOperatingSystem) validateFeatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Features) { // not required
		return nil
	}

	if m.Features != nil {
		if err := m.Features.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system" + "." + "features")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system" + "." + "features")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this server data attributes operating system based on the context it is used
func (m *ServerDataAttributesOperatingSystem) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDistro(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFeatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ServerDataAttributesOperatingSystem) contextValidateDistro(ctx context.Context, formats strfmt.Registry) error {

	if m.Distro != nil {

		if swag.IsZero(m.Distro) { // not required
			return nil
		}

		if err := m.Distro.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system" + "." + "distro")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system" + "." + "distro")
			}
			return err
		}
	}

	return nil
}

func (m *ServerDataAttributesOperatingSystem) contextValidateFeatures(ctx context.Context, formats strfmt.Registry) error {

	if m.Features != nil {

		if swag.IsZero(m.Features) { // not required
			return nil
		}

		if err := m.Features.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes" + "." + "operating_system" + "." + "features")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("attributes" + "." + "operating_system" + "." + "features")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystem) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystem) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributesOperatingSystem
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ServerDataAttributesOperatingSystemDistro server data attributes operating system distro
//
// swagger:model ServerDataAttributesOperatingSystemDistro
type ServerDataAttributesOperatingSystemDistro struct {

	// The OS Distro name
	Name string `json:"name,omitempty"`

	// The OS Distro Series
	Series string `json:"series,omitempty"`

	// The OS Distro slug
	Slug string `json:"slug,omitempty"`
}

// Validate validates this server data attributes operating system distro
func (m *ServerDataAttributesOperatingSystemDistro) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this server data attributes operating system distro based on context it is used
func (m *ServerDataAttributesOperatingSystemDistro) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystemDistro) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystemDistro) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributesOperatingSystemDistro
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ServerDataAttributesOperatingSystemFeatures server data attributes operating system features
//
// swagger:model ServerDataAttributesOperatingSystemFeatures
type ServerDataAttributesOperatingSystemFeatures struct {

	// raid
	Raid bool `json:"raid,omitempty"`

	// ssh keys
	SSHKeys bool `json:"ssh_keys,omitempty"`

	// user data
	UserData bool `json:"user_data,omitempty"`
}

// Validate validates this server data attributes operating system features
func (m *ServerDataAttributesOperatingSystemFeatures) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this server data attributes operating system features based on context it is used
func (m *ServerDataAttributesOperatingSystemFeatures) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystemFeatures) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributesOperatingSystemFeatures) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributesOperatingSystemFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ServerDataAttributesPlan server data attributes plan
//
// swagger:model ServerDataAttributesPlan
type ServerDataAttributesPlan struct {

	// hourly/monthly pricing. Defaults to `hourly`. Appliable for `on_demand` projects only.
	Billing *string `json:"billing,omitempty"`

	// The plan ID
	ID string `json:"id,omitempty"`

	// The plan name
	Name string `json:"name,omitempty"`
}

// Validate validates this server data attributes plan
func (m *ServerDataAttributesPlan) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this server data attributes plan based on context it is used
func (m *ServerDataAttributesPlan) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributesPlan) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributesPlan) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributesPlan
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ServerDataAttributesSpecs server data attributes specs
//
// swagger:model ServerDataAttributesSpecs
type ServerDataAttributesSpecs struct {

	// cpu
	CPU string `json:"cpu,omitempty"`

	// disk
	Disk string `json:"disk,omitempty"`

	// ram
	RAM string `json:"ram,omitempty"`
}

// Validate validates this server data attributes specs
func (m *ServerDataAttributesSpecs) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this server data attributes specs based on context it is used
func (m *ServerDataAttributesSpecs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ServerDataAttributesSpecs) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ServerDataAttributesSpecs) UnmarshalBinary(b []byte) error {
	var res ServerDataAttributesSpecs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
